### 泛型

* 虚拟机中没有泛型
* 泛型所有的参数类型都会被它们的限定类型替换
* 桥方法用来保持多态
* 必要时插入强制类型转换

#### 1.简单泛型类的定义

泛型类用于操作一个或者多个类型变量的类，定义如下所示。

Pair<T>用T指定数据类型（不能用基本数据类型）

类型变量通常用简短的大写字母指定，如E表示元素，K、V表示键值对。T表示任意类型。

```java
public class Pair<T> {

    private T first;
    private T second;
    
    public Pair() {
        first = null;
        second = null;
    }

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public T getSecond() {
        return second;
    }

    public void setSecond(T second) {
        this.second = second;
    }
}
```

有了上面的定义，就可以使用Pair类包装任意数据了。

```java 
Pair<String> strs = new Pair("Str1","Str2");
Pair<Integer> ints = new Pair(11,22);
......
```

#### 2.泛型方法

泛型方法的定义如下,可以定义在泛型类中，也可以定义在普通类中。

```java
public class ArrayAlg {
    public static <T> T getMiddle(T... a) {
        return a[a.length / 2];
    }
}
```

那么返回值怎么确定呢？

调用泛型方法的时候，在方法名前的尖括号指定返回值类型。但是大多数情况下是可以省略的。因为编译器是可以推断出的。比如下面的例子，返回值一定是String。

```java
String middle = ArrayAlg.<String>getMiddle("Leo", "play", "Chris","James");
```

但是再看下面例子的返回值是什么类型？

```java
ArrayAlg.getMiddle(2.14, 1289, 0);
```

int还是double？返回的是1289，它本身是个int，但是三个参数会不会转为同一个统一的类型double呢？

如果将返回值指定为double的话，编译器会报错的，指明这是不合适的返回值类型。为什么？

编译器会将参数打包，上面的参数会打包成一个Double和两个Integer，然后寻找二者的共同超类。就是Number和Comparable。最终确定为Number。因为Double和Integer都是继承自Number，本身并无直接关系。

补救措施：

```java
Double middle = ArrayAlg.getMiddle(2.14D, 1289D, 0D);
```

#### 3.泛型约束符

假设这样一个方法，参数接收一个数组，方法内部将数组元素逐个比较，返回数组的最小值。如果要实现这样一个功能，数组元素应该实现一个Comparable接口便于比较。怎么限制？如下：

```java
public static <T extends Comparable> T getmin(T[] a){}
```

使用extends关键字来进行约束，这样该方法就只能被元素实现了Comparable接口的数组调用.

```java 
public static <T extends Comparable & Serializable> T getmin(T[] a) {
    if (a == null || a.length < 1) return null;
    T smallest = a[0];
    for (int i = 0; i < a.length; i++) {
        if (smallest.compareTo(a[i]) > 0) {
            smallest = a[i];
        }
    }
    return smallest;
}
```

一个类型可以有多个限定用&分割，如果用类做限定的话只能有一个。

```java
<T extends Comparable & Serializable & Temporal>
```

#### 4.泛型和虚拟机

原始类型：擦除泛型信息之后，字节码保留的类型变量的真正类型。

##### ***a.类型检查***

类型检查是针对引用的，而且是在编译之前。

```java
Pair<String> pair = new Pair<>();
pair.setSecond("Leo");
pair.setSecond(123);	//编译就会报错
```

但是可以越过这个阶段，

```java
Pair<String> pair = new Pair<>();
try {
    pair.getClass().getMethod("setSecond",Object.class).invoke(pair,1234);
} catch (Exception e) {
    e.printStackTrace();
}
System.out.println(String.valueOf(pair.getSecond()));
```

通过反射可以将int类型的值设到Pair中.

再看一个例子：

```java
new Pair<String>().setSecond("Leo");//编译通过
new Pair<String>().setSecond(1234);//编译错误
```

以上两个例子说明，泛型检查只是在编译之前，而且泛型的检查是针对引用的。

##### ***b.类型擦除***

定义的泛型类型会有相对应的原始类型，原始类型用第一个限定的类型变量替换。没有限定的替换为Object。

```java 
public class Pair<T> {
    private T first;
    private T second;
}
```

上面的例子T最终被替换为Object

```java 
public class Pair {
    private Object first;
    private Object second;
}
```

再看

```java
public static <T extends Comparable & Serializable & Temporal> T getmin(T[] a) {
    if (a == null || a.length < 1) return null;
    T smallest = a[0];
    for (int i = 0; i < a.length; i++) {
        if (smallest.compareTo(a[i]) > 0) {
            smallest = a[i];
        }
    }
    return smallest;
}
```

因为第一个限定符是Comparable，类型擦除后变为：

```java
public static Comparable getmin(Comparable[] a) {
    if (a == null || a.length < 1) return null;
    Comparable smallest = a[0];
    for (int i = 0; i < a.length; i++) {
        if (smallest.compareTo(a[i]) > 0) {
            smallest = a[i];
        }
    }
    return smallest;
}
```

如果Serializable是第一个限定符，编译器在必要的时候会进行强转，所以单纯的标记型接口尽量放在限定列表后面。



##### ***c.类型擦除后的泛型自动转换***

以Pair<T>举例，编译器会将T替换为Object，但是我们存取的一个对象类型的时候编译器是如何做的。比如

```java 
Pair pair = new Pair();
pair.first = new Employee();
Employee pFirst = pair.getFirst();
```

在擦除返回类型之后，编译器会加入强制类型转换。以Pair.getFirst()举例，编译器会将它翻译成两条指令：

* 对原始方法Pair.getFirst()的调用
* 将返回的Object类型强转为Employee类型。

插入的时候也是一样的。



##### ***d.泛型方法擦除后的翻译***

我们有这么一个类，用来指定一个日期区间，并覆写setSecond方法确保日期不会越界。

```java
public class DateInterval extends Pair<LocalDate> {
    @Override
    public void setSecond(LocalDate second) {
        System.out.println("Override second method");
    }
}
```

这个类擦除之后变成什么？

我们直接用javap命令查看一下

`➜  javap -s DateInterval `

```shell
Compiled from "DateInterval.java"
public class generic.DateInterval extends generic.Pair<java.time.LocalDate> {
  public generic.DateInterval();
    descriptor: ()V

  public void setSecond(java.time.LocalDate);
    descriptor: (Ljava/time/LocalDate;)V

  public void setSecond(java.lang.Object);
    descriptor: (Ljava/lang/Object;)V
}
```

为什么有两个setSecond方法，除了我们泛型指定的LocalDate之外还有一个接收Object作为参数的重载方法。 

下面语句:

```java
DateInterval interval = new DateInterval()；
Pair<LocalDate> pair = interval;
pair.setSecond(xxx);
```

pair引用的是DateInterval对象，所以应该调用DateInterval的setSecond方法。但类型擦除之后，Pair对象调用到的就是setSecond(Object)

但是子类明明覆写了setSecond方法：

```java
@Override
public void setSecond(LocalDate second) {
    System.out.println("Override second method");
}
```

等等，这是覆写还是重载？为什么覆写变成了重载，泛型的擦除让我们的子类不再满足多态的特性了，JVM还明白我的意思吗？

所以JAVA要来弥补这个做法, 我们再次看下编译后的字节码:

```
➜  src javap -c generic.DateInterval  
Compiled from "DateInterval.java"
public class generic.DateInterval extends generic.Pair<java.time.LocalDate> {

  public void setSecond(java.time.LocalDate);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
				......
  public void setSecond(java.lang.Object);
    Code:
       0: aload_0
       1: aload_1
       2: checkcast     #14                 // class java/time/LocalDate
       5: invokevirtual #15                 // Method setSecond:(Ljava/time/LocalDate;)V
       8: return
}

```

可以看到在接收Object作为参数的方法内部，最终调用的还是`Method setSecond:(Ljava/time/LocalDate;)V`,JAVA 通过这种方式来解决冲突，这个方式叫做桥方法。

#### 5.注意情形

**不能使用基本数据类型**

**运行时类型查询只适用于原始类型**

比如`if (list instanceof Pair<String>)`是错误的，只能`if (list instanceof Pair)`

**不能创建参数化类型的数组**

比如`Pair<String> [] arrs = new Pair<String>[5];`这是错误的，只是不能用`new Pair<String>`来实例化，可以用其他办法，比如通配型数组

```java 
Pair<String> [] arrs = (Pair<String>[]) new Pair<?>[5];
Pair<String> [] arrs = new Pair[5];
```

**不能实例化泛型的对象或数组**

```java
T instance = new T()
T[] arr = new T[3]  都是不合法的
```

**静态上下文类型变量失效**

```java
public class Pair<T> {
    public static T instance;//非法的定义
}
```

**不能抛出或者捕获泛型类的实例**

#### 6.泛型的继承规则

```java
Pair<List> pairP = new Pair<>();
Pair<ArrayList> pairA = paitP;//非法
```

二者是没有任何关系的两个对象，虽然List是ArrayList的父类接口，看起来迷惑。